#!/usr/bin/perl
# author: seth
# description: downloads last.fm user data and scrobbles radio streams and 
#		bandcamp music to last.fm; 
#
# tab-size: 2

use strict;
use warnings;
use Carp;                     # better output on errors for debugging purposes
use Data::Dumper;
use Getopt::Long qw(:config bundling);
use Pod::Usage;
use POSIX qw/strftime/;       # format timestamp
use Term::ReadKey;            # used for user input

$main::VERSION = '0.7';
binmode STDOUT, ":utf8";

# functions
# =========
# sub _die
# 	verbose output on errors
#
# sub _warn
# 	verbose output on warnings
#
# sub _cleanup
# 	clean up everything before leaving
#
# sub _cleanup_and_die
#
# sub _cleanup_and_exit
#
# sub _cleanup_file
#		delete (previously created) file
#
# sub syntaxCheck
# 	check input of user
#
# MPlayerWrapper: mplayer wrapper class 
# -------------------------------------
# sub new
# 	constructor
# sub cmd
# 	send sommand to mplayer
# sub enqueue
# 	enqueue track to playlist
# sub get_current_file
# 	get currently played file
# sub get_pos
# 	get current position in current track
# sub get_time_is
# 	time format conversion
# sub get_time_iso_
# 	time format conversion
# sub init
# 	look for mplayer, set internal path to mplayer
# sub is_running
# 	return 1 if mplayer is running
# sub keypress_handler
# 	tries to imitate some mplayer shortcut bindings
# 	returns undef if no key is pressed, 0 if key is unknown, 1 if key is known
# sub mplayer_std_handler
# 	handler for stdout and stderr output
# sub msg
# 	print message to screen
# sub play
# 	play track
# sub read_key
# 	read a key, returns a array ref, containing the key (as char) and possible 
# 	escape sequences as ord(.)
# sub quit
# 	quit
# sub run
#		starts mplayer in a separate process
# sub wait_for_end
# 	wait for end of playlist
# sub wait_for_last_track
# 	wait until beginn of last track in playlist
# sub wait_for_track
# 	wait for begin of given track
#
# Lastfm_dl: main class for last.fm stuff
# ---------------------------------------
# sub new
# 	constructor
#
# sub authenticate
# 	unused: last.fm authentication
#
# sub bandcamp_dl_album_random_track
#		download a random track of a given album
#
# sub bandcamp_dl_track
#		download a track from bandcamp.com
#
# sub bandcamp_radio
# 	play bandcamp music like a radio station
#
# sub collect_trackinfos_bandcamp
# 	given an url to a bandcamp album, this function returns information on 
# 	album title, tracks (number, title, duration) and artist in a last.fm
# 	compatible format
#
# sub collect_trackinfos_youtube
# 	given an url to a youtube album, this function tries to return information on 
# 	album title, tracks (number, title, duration) and artist in a last.fm
# 	compatible format
#
# sub delete_ugly_chars
# 	convert string to nicer filename
#
# sub get_all_user_data
# 	get all important user statistics from last.fm for a given user and save it to 
# 	a json file.
#
# sub get_http_content
# 	given an url, a http method (GET or POST) and additional params, this function
# 	returns the content of the page and the http status code
#
# sub get_lastfm
# 	wrapper for last.fm api, returns results as a json-like struct
#
# sub get_mobile_session
# 	login at last.fm as a given user, returns a session key
#
# sub get_state
# 	get present scrobbling state
#
# sub get_time_iso
# 	get date and time as formatted string "%Y-%m-%d%H:%M:%S" from given (or current)
# 	unix timestamp
#
# sub get_time_iso_
# 	get date and time as formatted string "%Y-%m-%d %H:%M:%S" from given 
# 	(or current) unix timestamp
#
# sub get_time_mm_ss2s
# 	convert time duration format mm:ss to number of seconds
#
# sub get_time_unix
# 	get unix timestamp from iso-like formatted string "%Y-%m-%d %H:%M:%S" 
# 	(using timelocal or timegm)
#
# sub get_token
# 	get a last.fm token
#
# sub get_session
# 	unused: get a last.fm session
#
# sub get_user_info
# 	unused: get info on a last.fm user
#
# sub get_user_past_events
# 	get all events that a last.fm user went
#
# sub load_json_file
# 	load a json file into a perl struct
#
# sub msg
# 	write some info message to STDOUT
#
# sub resolve_radio_station_names
# 	given short name, return complete url of a radio station
#
# sub save_json_file
# 	save a perl struct to a json file
#
# sub scrobble_forked
# 	non-blocking call of scrobble
#
# sub scrobble
# 	scrobble a given track to the current last.fm profile or update the 
# 	"now playing" track
#
# sub scrobble_from_source
# 	handle different kind of music sources:	
# 	bandcamp-album-url, radio stream, json file
#
# sub scrobble_keypress_handler
# 	a simple user interface can be used to skip/stop scrobbling when using a stream
#
# sub set_mp3_tags
# 	for a given file set mp3 tags via lastfm struct
#
# sub set_state
# 	set scrobbling state (for a simple state machine)
#
# sub stream_connect
# 	given an url, connect to a http(s)-shoutcast-stream; 
# 	return socket and icy-metadata
#
# sub stream_parse_icy_info
# 	given a icy info string, try to get artist and title
#
# sub stream_read_current_track
# 	after stream_connect, this function reads the stream from the socket.
# 	forwards the pure music stream (w/o icy info) to a given process (like vlc) or
# 	a file.
# 	the icy info is used to scrobble the track into a given last.fm profile.
#
# sub youtube_get_video_length{
# 	given a youtube video url, this function returns the length of the video in 
# 	seconds

$| = 1; # don't buffer; stdout is hot now
my @_clean_up_files = ();

# Carp::Always
sub _die {
	die @_ if ref($_[0]);
	if($_[-1] =~ /\n$/s){ # $_ is a read-only value
		my $arg = pop @_;
		$arg =~ s/.*\K at .*? line .*?\n$//s;
		push @_, $arg;
	}
	unshift @_, strftime("%Y-%m-%d %H:%M:%S ", gmtime());
	die &Carp::longmess;
}

sub _warn {
	if($_[-1] =~ /\n$/s){ # $_ is a read-only value
		my $arg = pop @_;
		$arg =~ s/.*\K at .*? line .*?\n$//s;
		push @_, $arg;
	}
	unshift @_, strftime("%Y-%m-%d %H:%M:%S ", gmtime());
	warn &Carp::longmess;
}

sub _cleanup{
	ReadMode('restore') if defined &ReadMode;
	for my $f(@_clean_up_files){
		unlink $f if -f $f;
		# delete directory of file if empty
		for(my $dir = $f; $dir =~ /^(.+)\/[^\/]+\z/;){
			$dir = $1;
			rmdir $dir or last;
		}
	}
}

sub _cleanup_and_die{
	_cleanup;
	_die(@_);
}

sub _cleanup_and_exit{
	_cleanup;
	exit 1;
}

sub _cleanup_file{
	my $filename = shift;
	my $deleted = 0;
	if(-f $filename && 0 < grep {$filename eq $_} @_clean_up_files){
		unlink $filename;
		$deleted = 1;
	}
	return $deleted;
}

$SIG{'__DIE__'} = \&_cleanup_and_die;
$SIG{'INT'}     = \&_cleanup_and_exit;
$SIG{'KILL'}    = \&_cleanup_and_exit;
$SIG{'TERM'}    = \&_cleanup_and_exit;
$SIG{__WARN__}  = \&_warn;

sub syntaxCheck{
	my %params = ( # default cli params
		'dl'            => 0,     # download user data
		'password'      => undef, # password
		'password-file' => "$ENV{'HOME'}/.password_lastfm", # file containing password
		'radio'         => undef, # play radio station or album and scrobble
		'scrobble'      => undef, # file or radio station to scrobble (without playing)
		'timestamp'     => undef, # timestamp in utc for scrobbling
		'timestamp-local' => undef, # timestamp in local time for scrobbling
		'stream-out'    => '| vlc -', # the destination for streaming data
		'test'          => undef, # testing only
		'keep'          => 0,     # keep downloaded tracks (when listending to bandcamp radio)
		'user'          => undef, # user-name
		'verbose'       => 1,     # trace; grade of verbosity
		'version'       => 0,     # diplay version and exit
	);
	GetOptions(\%params,
		"dl",
		"keep",
		"password=s",
		"password-file=s",
		"radio|r=s",
		"scrobble|s=s",
		"stream-out=s",
		"timestamp=s",
		"timestamp-local=s",
		"test|t",
		"user|u=s",
		"silent|quiet|q" => sub { $params{'verbose'} = 0;},
		"very-verbose" => sub { $params{'verbose'} = 2;},
		"verbose|v:+",
		# auto_version will not auto make use of 'V'
		"version|V" => sub { Getopt::Long::VersionMessage();}, 
		# auto_help will not auto make use of 'h'
		"help|?|h" => sub { Getopt::Long::HelpMessage(
				-verbose=>99, -sections=>"NAME|SYNOPSIS");}, 
		"man" => sub { pod2usage(-exitval=>0, -verbose=>2);},
	) or pod2usage(-exitval=>2);
	$params{'verbose'} = 1 unless exists $params{'verbose'};
	# additional params
	my @additional_params = (0,0); # number of additional params (min, max);
	if(@ARGV < $additional_params[0] 
			or ($additional_params[1] != -1 and @ARGV > $additional_params[1])){
		if($additional_params[0] == $additional_params[1]){
			print "number of arguments must be exactly $additional_params[0], but is " 
				. (0 + @ARGV) . ".\n";
		}else{
			print "number of arguments must be at least $additional_params[0]"
				. ' and at most ' 
				. ($additional_params[1] == -1 ? 'inf' : $additional_params[1]) 
				. ", but is " . (0 + @ARGV) . ".\n";
		}
		pod2usage(-exitval => 2);
	}
	return \%params;
}

{
	package MPlayerWrapper;
	use Data::Dumper;           # debug output
	use IPC::Run qw(start pump finish);
	use POSIX qw/strftime/;     # format timestamp
	use Term::ReadKey;          # used for user input
	use Time::HiRes qw(usleep); # debug output

	sub new {
		my $class  = shift;
		my $params = shift;
		my $self  = bless {
			'stderr'  => [],
			'handle'  => undef,
			'in'      => undef,
			'mplayer' => 'mplayer',
			'pause_file' => 'pause_indicating_file',
			'played'  => [],
			'retval'  => undef, # only filled, but not used yet
			'stdout'  => [],
			'verbose' => $params->{'verbose'} // 1,
		}, $class;
		$self->init();
		push @_clean_up_files, $self->{'pause_file'};
		$self->run();
		$self;
	}

	sub cmd{
		my $self = shift;
		my $cmd  = shift;
		my $min_verbosity = shift // 1;
		$self->msg($min_verbosity, "mplayer cmd: $cmd");
		if($self->is_running){
			$self->{'in'} = "$cmd\n";
			pump $self->{'handle'};
			return 1;
		}else{
			$self->msg(0, "mplayer is not running. cannot send '$cmd'", 'error');
			return 0;
		}
	}

	sub enqueue{
		my $self = shift;
		my $file = shift;
		my $enqueue = 1;
		return $self->play($file, $enqueue);
	}

	sub get_current_file{
		my $self = shift;
		my $min_verbosity = shift // 3;
		my $file;
		if($self->is_running){
			$self->cmd('get_file_name', $min_verbosity);
			if($self->{'last_stdout_line'} =~ /ANS_FILENAME='(.*)'/){
				$file = $1;
			}
		}
		return $file;
	}

	sub get_pos{
		my $self = shift;
		my $type = shift // 'simple';
		my $min_verbosity = shift // 3;
		my $pos;
		if($self->is_running){
			$self->cmd('get_time_pos', $min_verbosity);
			if($self->{'last_stdout_line'} =~ /ANS_TIME_POSITION='(.*)'/){
				$pos = $1;
			}
			if($type eq 'full'){
				$pos = {'seconds' => $pos};
				$self->cmd('get_percent_pos', $min_verbosity);
				if($self->{'last_stdout_line'} =~ /ANS_PERCENT_POSITION='(.*)'/){
					$pos->{'percent'} = $1;
				}
				$self->cmd('get_time_length', $min_verbosity);
				if($self->{'last_stdout_line'} =~ /ANS_LENGTH='(.*)'/){
					$pos->{'length'} = $1;
				}
				#$pos->{'file'} = $self->get_current_file($min_verbosity);
			}
		}
		return $pos;
	}

	sub get_time_iso{
		my $self = shift;
		my $unixtimestamp = shift // time();
		return strftime("%Y-%m-%dT%H:%M:%S", gmtime($unixtimestamp));
	}

	sub get_time_iso_{
		my $self = shift;
		my $unixtimestamp = shift // time();
		return strftime("%Y-%m-%d %H:%M:%S", gmtime($unixtimestamp));
	}

	sub init{
		my $self = shift;
		my $mplayer = `which mplayer`;
		chomp($mplayer);
		if($mplayer ne ''){
			$self->{'mplayer'} = $mplayer;
			return 1;
		}else{
			return 0;
		}
	}

	sub is_running{
		my $self = shift;
		return defined $self->{'handle'};
	}

	sub keypress_handler{
		my $self = shift;
		my $seq  = shift;
		my $return_value;
		if(defined $seq && @$seq > 0){
			my $key = $seq->[0];
			$self->msg(2, "key: " . length($key) . ", ". ord($key));
			$return_value = 1;
			if($key eq 'h'){
				my @str = (
					'mplayer help',
					' h                print this help',
					' <-  or  ->       seek backward/forward 10 seconds',
					' down or up       seek backward/forward  1 minute',
					# TODO: ' pgdown or pgup   seek backward/forward 10 minutes',
					' < or >           step backward/forward in playlist',
					'                  backward is possible only if --keep is set',
					' SPACE            pause movie (press any key to continue)',
					' p                print current position information on track',
					' q or ESC         stop playing and quit program',
					' + or -           adjust audio delay by +/- 0.1 second',
					#' o               cycle OSD mode:  none / seekbar / seekbar + timer',
					' * or /           increase or decrease PCM volume',
					#' x or z          adjust subtitle delay by +/- 0.1 second',
					#' r or t          adjust subtitle position up/down, also see -vf expand',
				);
				$self->msg(1, join("\n", @str));
			}elsif(ord($key) == 27){
				if(@$seq == 1){
					$self->quit;
				}elsif(@$seq == 3){
					if($seq->[1] == 91 && $seq->[2] == 67){
						$self->cmd("seek 10"); # ->
					}elsif($seq->[1] == 91 && $seq->[2] == 68){
						$self->cmd("seek -10"); # <-
					}elsif($seq->[1] == 91 && $seq->[2] == 65){
						$self->cmd("seek 60"); # up
					}elsif($seq->[1] == 91 && $seq->[2] == 66){
						$self->cmd("seek -60"); # down
					}else{
						$self->msg(4, Dumper($seq));
						$self->msg(3, 'unrecognized short cut key');
						$return_value = 0;
					}
				}else{
					$self->msg(4, Dumper($seq));
					$self->msg(3, 'unrecognized short cut key');
					$return_value = 0;
				}
			}elsif($key eq '<'){
				$self->cmd("pt_step -1");
			}elsif($key eq '>' or $key eq 'd'){
				$self->cmd("pt_step 1");
			}elsif($key eq ' '){
				if(-f $self->{'pause_file'}){
					# forgotten to delete $self->{'pause_file'}?
				}else{
					open(my $FILE, '>', $self->{'pause_file'}) 
						|| die("cannot create file: " . $!);
					close($FILE); 
					$self->cmd("pause");
					$self->msg(2, 'paused, waiting for any key to continue');
					until($key = ReadKey(-1)){
						usleep 200_000;
					}
					$self->cmd("pause");
				}
				unlink $self->{'pause_file'};
			}elsif($key eq 'p'){
				$self->get_pos('full');
			}elsif($key eq 'q'){
				$self->quit;
			}elsif($key eq '+'){
				$self->cmd("audio_delay 0.1");
			}elsif($key eq '-'){
				$self->cmd("audio_delay -0.1");
			}elsif($key eq '*'){
				$self->cmd("volume 0.1");
			}elsif($key eq '/'){
				$self->cmd("volume -0.1");
			}else{
				$self->msg(4, Dumper($key));
				$self->msg(3, 'unrecognized short cut key');
				$return_value = 0;
			}
		}
		return $return_value;
	}

	sub mplayer_std_handler{
		my $self = shift;
		my $type = shift;
		my $msg  = shift;
		my @complete_msgs = split /[\n\r]+/, $msg;
		for my $cmsg(@complete_msgs){
			utf8::decode($cmsg); # don't know, whether this is correct here.
			chomp($cmsg);
			if($self->{'last_' . $type . '_line'} ne $cmsg){
				push @{$self->{$type}}, $cmsg;
				$self->{'last_' . $type . '_line'} = $cmsg;
				$cmsg =~ s/^/$type: /mg;
				if($type eq 'stderr'){
					if($self->{'verbose'} > 1	
						|| (
							$cmsg !~ /^stderr: Failed to open LIRC/
							&& $cmsg !~ /^stderr: Requested audio codec family .* not available\./
							&& $cmsg !~ /^stderr: Enable it at compilation\./
						)
					){
						$cmsg =~ s/^stderr:/mpl_err:/;
						$self->msg(0, $cmsg);
					}
				}else{ # stdout
					if($self->{'verbose'} > 2 
						|| (
							$cmsg !~ /^stdout: AO: \[pulse\] 44100Hz/
							&& $cmsg !~ /^stdout: Audio only file format/
							&& $cmsg !~ /^stdout: AUDIO: 44100 Hz/
							&& $cmsg !~ /^stdout:\s(?:Cannot\sopen\sfile|Failed\sto\sopen)\s
								'?\/.*mplayer\/input\.conf/x
							&& $cmsg !~ /^stdout: libav(?:codec|format) version/
							&& $cmsg !~ /^stdout: Load subtitles in/
							&& $cmsg !~ /^stdout: Mismatching header version/
							&& $cmsg !~ /^stdout: Opening audio decoder:/
							&& $cmsg !~ /^stdout: [\s=]*$/
							&& $cmsg !~ /^stdout: Selected audio codec:/
							&& $cmsg !~ /^stdout: Video: no video/
						) 
						&& (
							$self->{'verbose'} > 1 
							|| (
								$cmsg !~ /^stdout: MPlayer2? .* 2000-2... MPlayer Team/
							)
						)
					){
						# that's probably nicer in this context
						$cmsg =~ s/^stdout:/mplayer:/;
						$self->msg(1, $cmsg);
					}
				}
			}
		}
		return 1;
	}

	sub msg{
		my $self           = shift;
		my $verb_threshold = shift;
		my $msg            = shift;
		my $type           = shift;
		my $caller_inc     = shift // 0;
		return 0 if $self->{'verbose'} < $verb_threshold;
		push @{$self->{'_messages'}}, {'type' => $type, 'msg' => $msg} if defined $type;
		$type = (defined $type ? "$type in ": '');
		my $timestamp = $self->get_time_iso_;
		# my ($package, $filename, $line, $subr, $has_args, $wantarray, $evaltext, 
		# $is_require, $hints, $bitmask, $hinthash) = caller(0);
		my @callers = caller(0 + $caller_inc);
		my $line = $callers[2];
		@callers = caller(1 + $caller_inc);
		my $subr = $callers[3] // '[no sub]';
		if($self->{'verbose'} > 1){
			print "$timestamp $type$subr:$line: ";
		}elsif($type ne ''){
			print "$type$subr:$line: ";
		}
		print "$msg\n";
		return 1;
	}

	sub play{
		my $self = shift;
		my $file = shift;
		my $enqueue = shift;
		if($enqueue){
			$self->cmd("loadfile '$file' 1");
		}else{
			$self->cmd("loadfile '$file'");
		}
		push @{$self->{'played'}}, $file;
		return 1;
	}

	sub quit{
		my $self = shift;
		if($self->is_running){
			$self->cmd('quit');
			finish $self->{'handle'};
			undef $self->{'handle'};
			$self->{'retval'} = $?/256;
			return 1;
		}else{
			$self->msg(0, 'mplayer is not running, so cannot be exited', 'warning');
		}
		return 0;
	}

	sub read_key{
		my $self = shift;
		my $seq;
		if(defined &ReadKey){
			my $key = ReadKey(-1);
			if(defined $key){
				$seq = [$key];
				# cope with escape sequences
				if(ord($key) == 27){
					while($key = ReadKey(-1)){
						push @$seq, ord($key);
						$self->msg(3, $seq->[-1]);
					}
				}
			}
		}
		return $seq;
	}

	sub run{
		my $self = shift;
		my $cmd  = "$self->{'mplayer'} -slave -idle -quiet";
		$self->msg(1, "command: '$cmd'");
		$self->{'last_stdout_line'} = '';
		$self->{'last_stderr_line'} = '';
		my $stdout_handler = sub {
			$self->mplayer_std_handler('stdout', @_);
		};
		my $stderr_handler = sub {
			$self->mplayer_std_handler('stderr', @_);
		};
		$self->{'handle'} = start(
			[split ' ', $cmd], \$self->{'in'}, $stdout_handler, $stderr_handler);
		# will die if mplayer not found
		return $self->is_running;
	}

	sub wait_for_end{
		my $self = shift;
		ReadMode('cbreak') if defined &ReadMode;
		for(my ($pos, $pos_old); 
			$self->is_running() && (!defined($pos) || $pos != $pos_old); 
			$pos = $self->get_pos('simple')
		){
			$pos_old = $pos // 0;
			my $seq = $self->read_key;
			$self->keypress_handler($seq);
			# must not be less than 100k, because mplayers output frequency is about 10Hz
			usleep 300_000; 
		}
		ReadMode('restore') if defined &ReadMode;
		return 1;
	}

	sub wait_for_last_track{
		my $self = shift;
		if(@{$self->{'played'}} > 1){
			$self->msg(2, "waiting until track '$self->{'played'}[-1]' will start");
			return $self->wait_for_track($self->{'played'}[-1]);
		}else{
			$self->msg(2, 'not waiting because play list size = ' 
				. scalar(@{$self->{'played'}}));
			return 0;
		}
	}

	sub wait_for_track{
		my $self = shift;
		my $file_w_path = shift;
		my $file_wo_path;
		if($file_w_path =~ /([^\/]+)$/){
			$file_wo_path = $1;
		}
		my $wait_ns = 100_000;
		my $undef_counter = 0;
		my $counter_max = 5 * 1e7 / $wait_ns; # 5 seconds
		my $curr_file;
		# key-press handling has to be done outside of this function, see wait_for_end
		while(
			$self->is_running() # while mplayer is running and 
			&& $undef_counter < $counter_max # current track is not undefined for >5 
			# seconds and 
			&& (!defined($curr_file) # current track is not track we are waiting for
				|| ($curr_file ne $file_w_path && $curr_file ne $file_wo_path)
			)
		){
			if(defined $curr_file){
				$undef_counter = 0;
			}else{
				++$undef_counter;
			}
			usleep $wait_ns;
			# cope with pause:
			# any mplayer command will break the pause, i.e., forking the mplayer wrapper
			# will make 'pause' fail, because get_current_file will be called every 100ms.
			# that's why an empty file is used for indicating a pause
			my $pause_counter = 0;
			while(-f $self->{'pause_file'}){
				if($pause_counter == 0 
					|| $pause_counter >= 60 * 1e7 / $wait_ns){
					$self->msg(1, "pausing (press SPACE to continue)");
					$pause_counter = 0;
				}
				++$pause_counter;
				usleep $wait_ns;
			}
			$curr_file = $self->get_current_file();
		}
		if(defined $curr_file){
			$self->msg(2, "waited until '$curr_file'");
		}
		return 1;
	}

}

{
	package Lastfm_dl;
	use Data::Dumper;
	use Digest::MD5 qw(md5_hex);
	use Encode;                 # encode
	use IO::Socket::INET;       # for receiving radio stream
	use JSON;                   # JSON::from_json
	use LWP::UserAgent;         # fast, small web browser
	use MP3::Tag;               # write mp3 tags
	use POSIX qw/strftime/;     # format timestamp
	use Term::ReadKey;          # used for user input
	use Time::HiRes qw(usleep); # debug output
	use Time::Local;            # timegm, timelocal
	use URI::Escape;            # uri_escape_utf8
	use YAML;

	sub new{
		my $class = shift;
		my $params = shift;
		my $self = bless {
			'api_key'       => '33068e0258f716d75a8265da4c71d2b2',
			'dl_path'       => 'downloaded_music',
			'keep_dl'       => $params->{'keep'},
			'lastfm_root'   => 'https://ws.audioscrobbler.com/2.0/',
			'mplayer'       => undef,
			'password'      => $params->{'password'},
			'password_file' => $params->{'password-file'},
			'play_radio'    => $params->{'play-radio'},
			'session_key'   => undef,
			'shared_secret' => '4972ac93a09ce39fae4f7bf88adcaf91',
			'state'         => undef,
			'stats'         => {# used for statistics on radio/stream
				'music_bytes' => 0,
				'played'      => [],
				'start_time'  => time(),
			},
			'stream_out'    => $params->{'stream-out'},
			'socket'        => undef,
			'simulate'      => $params->{'test'},
			'timestamp'     => $params->{'timestamp'},
			'timestamp_local' => $params->{'timestamp-local'},
			'token'         => undef,
			'username'      => $params->{'username'},
			'verbose'       => $params->{'verbose'},
			'lastfm_methods' => {
				'auth.getmobilesession' => {
					'required' => ['password', 'username', 'api_key', 'api_sig'],
					'optional' => [],
				},
				'auth.getsession' => {
					'required' => ['token', 'api_key', 'api_sig'],
					'optional' => [],
				},
				'auth.gettoken' => {
					'required' => ['api_key', 'api_sig'],
					'optional' => [],
				},
				'track.scrobble' => {
					'required' => ['artist', 'track', 'timestamp', 'api_key', 'api_sig', 
						'sk'],
					'optional' => ['album', 'context', 'streamId', 'chosenByUser', 
						'trackNumber', 'mbid', 'albumArtist', 'duration'],
				},
				'track.updatenowplaying' => {
					'required' => ['artist', 'track', 'api_key', 'api_sig', 'sk'],
					'optional' => ['album', 'context', 'trackNumber', 'mbid', 'albumArtist', 
						'duration'],
				},
				'user.getartisttracks' => {
					'required' => ['user', 'artist', 'api_key'],
					'optional' => ['startTimestamp', 'page', 'endTimestamp'],
				},
				'user.getfriends' => {
					'required' => ['user', 'api_key'],
					'optional' => ['recenttracks', 'limit', 'page'],
				}, 
				'user.getinfo' => {
					'required' => ['user', 'api_key'],
					'optional' => [],
				}, 
				'user.getlovedtracks' => {
					'required' => ['user', 'api_key'],
					'optional' => ['limit', 'page'],
				},
				'user.getpersonaltags' => {
					'required' => ['user', 'tag', 'taggingtype', 'api_key'],
					'optional' => ['limit', 'page'],
				},
				'user.getrecenttracks' => {
					'required' => ['user', 'api_key'],
					'optional' => ['limit', 'page', 'from', 'extended', 'to'],
				},
				'user.gettopalbums' => {
					'required' => ['user', 'api_key'],
					'optional' => ['period', 'limit', 'page'],
				},
				'user.gettopartists' => {
					'required' => ['user', 'api_key'],
					'optional' => ['period', 'limit', 'page'],
				},
				'user.gettoptags' => {
					'required' => ['user', 'api_key'],
					'optional' => ['limit'],
				},
				'user.gettoptracks' => {
					'required' => ['user', 'api_key'],
					'optional' => ['period', 'limit', 'page'],
				},
				'user.getweeklyalbumchart' => {
					'required' => ['user', 'api_key'],
					'optional' => ['from', 'to'],
				},
				'user.getweeklyartistchart' => {
					'required' => ['user', 'api_key'],
					'optional' => ['from', 'to'],
				},
				'user.getweeklychartlist' => {
					'required' => ['user', 'api_key'],
					'optional' => [],
				},
				'user.getweeklytrackchart' => {
					'required' => ['user', 'api_key'],
					'optional' => ['from', 'to'],
				},
			},
		}, $class;
		return $self;
	}

	sub authenticate{
		my $self = shift;
		$self->get_token unless defined $self->{'token'};
		my $auth_url = 'https://www.last.fm/api/auth/?api_key=' . $self->{'api_key'} 
			. '&token=' . $self->{'token'};
		my ($http_code, $content) = $self->get_http_content($auth_url);
		return 1;
	}

	sub bandcamp_dl_album_random_track{
		my $self = shift;
		my $tracks = shift;
		my @dl_tracks = grep {defined $_->{'non_lastfm_url'}} @$tracks;
		my $random_track = $dl_tracks[int(rand(scalar(@dl_tracks)))];
		$random_track->{'non_lastfm_file'} = $self->bandcamp_dl_track($random_track);
		return $random_track;
	}

	sub bandcamp_dl_track{
		my $self = shift;
		my $trackinfo = shift;
		my $filename; 
		if(defined $trackinfo->{'non_lastfm_url'}){
			mkdir $self->{'dl_path'};
			my $readme_file = "$self->{'dl_path'}/readme.txt";
			unless(-f $readme_file){
				if(open(my $OUTFILE, '>', $readme_file)){
					print $OUTFILE 'this directory contains the mp3 files of the bandcamp ';
					print $OUTFILE 'tracks downloaded by dl_lfm.' . "\n" . 'they can be used';
					print $OUTFILE ' as remarkers, in case you forgot what you\'ve listened ';
					print $OUTFILE "to.\n" ;
					print $OUTFILE 'if you like a track, please consider buying the track or';
					print $OUTFILE ' full album at bandcamp.com.';
					close($OUTFILE);
				}else{
					$self->msg(0, "$!: '$readme_file'", 'error');
				}
			}
			mkdir $self->{'dl_path'} . '/' 
				. $self->delete_ugly_chars($trackinfo->{'artist'});
			my $dir = $self->{'dl_path'} . '/' 
				. $self->delete_ugly_chars($trackinfo->{'artist'}) . '/' 
				. $self->delete_ugly_chars($trackinfo->{'album'});
			mkdir $dir;
			$filename = sprintf('%s/%02d %s - %s.mp3', 
				$dir,
				$trackinfo->{'trackNumber'}, 
				$self->delete_ugly_chars($trackinfo->{'artist'}), 
				$self->delete_ugly_chars($trackinfo->{'track'})
			);
			if(-e $filename){
				$self->msg(1, "file '$filename' exists already");
			}else{ # download track
				my $cmd = "wget '$trackinfo->{'non_lastfm_url'}' -O '$filename'";
				push @_clean_up_files, $filename unless $self->{'keep_dl'};
				$self->msg(2, $cmd);
				unless($self->{'simulate'}){
					$cmd .= ' -q' if $self->{'verbose'} < 3;
					system($cmd);
				}
			}
			$self->set_mp3_tags($filename, $trackinfo);
		}else{
			$self->msg(0, 'don\'t know, where to download the track', 'warning');
		}
		return $filename;
	}

	sub bandcamp_radio{
		my $self     = shift;
		my $url      = shift;
		# https://bandcamp.com/tag/metal?page=2&sort_field=pop
		my $success = 0;
		if($url =~ /^https?:\/\/bandcamp\.com\/tag\/([a-z0-9]+)(\?.+|)$/){
			my $tag = $1;
			$self->msg(1, "reading page(s) of tag '$tag'");
			# get HTTP GET params from url
			my %params;
			if(length($2) > 0){
				my $paramstring = substr($2, 1);
				%params = map {/^(.+)=(.*)$/; ($1 => $2)} split /&/, $paramstring;
			}
			my $first_page = $params{'page'} // 1;
			$self->msg(5, Dumper(\%params));
			# get tag page
			my ($http_status, $content) = $self->get_http_content($url);
			# get number of pages with albums of this tag
			my $num_pages = 1;
			my @page_numbers = $content =~ /
				<li>
					<a\s
						class="[^"]+"\s
						href="\?page=([0-9]+)"\s
						rel="nofollow">[0-9]+
					<\/a>
				<\/li>/gxs;
			my $max_num = (@page_numbers > 0) ? (sort @page_numbers)[-1] : 1;
			$num_pages = $max_num - $first_page + 1;
			$self->msg(3, "number of tag pages = $num_pages, first page = $first_page");
			# play random tracks and scrobble them until mplayer stops
			if($self->{'play_radio'}){
				$self->{'mplayer'} = MPlayerWrapper->new({
						'verbose' => $self->{'verbose'},
					});
			}
			$self->set_state('scrobble');
			$self->bandcamp_radio_loop($first_page, $num_pages, \%params, $tag);
		}else{
			$self->msg(0, "could not read bandcamp tag url '$url'", 'error');
		}
		return $success;
	}

	sub bandcamp_radio_loop{
		my $self       = shift;
		my $first_page = shift;
		my $num_pages  = shift;
		my $params     = shift;
		my $tag        = shift;
		my $bandcamp_tag_base_path = 'https://bandcamp.com/tag';
		my @last_tracks = ();
		while($self->{'mplayer'}->is_running){
			# get random page (rebuild url)
			$self->msg(1, "get a random tag page from $first_page to " 
				. ($first_page + $num_pages - 1));
			$params->{'page'} = $first_page + int(rand($num_pages));
			$self->msg(2, "chose random page $params->{'page'}");
			my $url = "$bandcamp_tag_base_path/$tag?";
			while(my ($k, $v) = each %$params){
				$url .= "$k=$v&";
			}
			chop($url);
			my ($http_status, $content) = $self->get_http_content($url);
			if($http_status == 200){
				# collect albums urls
				my @albums = ($content =~ /
					<a\s+href="
					(https:\/\/[a-zA-Z0-9-]+\.bandcamp\.com\/album\/[^"]+)
					"\s+/gx);
				# goto random album and collect tracks information
				my $tracks = $self->collect_trackinfos_bandcamp(
					$albums[int(rand(scalar(@albums)))]);
				# download random track from album
				$self->msg(1, "choose random track and download");
				my $random_track = $self->bandcamp_dl_album_random_track($tracks);
				my $filename = $random_track->{'non_lastfm_file'};
				if(defined $filename){
					$self->msg(3, "chose random track '$filename'");
					$random_track->{'timestamp'} = undef;
					$random_track->{'chosenByUser'} = '0';
					push @last_tracks, $random_track;
					$self->msg(2, 'play list = ' . Dumper(\@last_tracks));
					# play and scrobble track
					$self->{'mplayer'}->enqueue($filename) if $self->{'play_radio'};
					$self->{'stats'}{'music_bytes'} += (stat $filename)[7];
					$self->msg(3, 'play list in mplayer = ' 
						. Dumper($self->{'mplayer'}->{'played'}));
					my $pid = fork();
					if(not defined $pid){
						$self->msg(0, 'resources not avilable.', 'error');
						die "$!";
					}elsif($pid == 0){
						$self->{'mplayer'}->wait_for_last_track() if $self->{'play_radio'};
						exit 0;
					}else{
						if(@{$self->{'mplayer'}{'played'}} > 1){
							if(@last_tracks > 1){
								if(defined $last_tracks[-2]->{'non_lastfm_about'}){
									$self->msg(1, $last_tracks[-2]->{'non_lastfm_about'});
								}
								if(defined $self->{'session_key'}){
									$self->scrobble_forked($last_tracks[-2], 'now playing');
								}
							}else{
								$self->msg(0, 'last_tracks array is too small.', 'error');
							}
							ReadMode('cbreak') if defined &ReadMode;
							while(waitpid($pid, POSIX::WNOHANG) == 0){
								my $seq = $self->{'mplayer'}->read_key;
								$self->{'mplayer'}->keypress_handler($seq);
								$self->scrobble_keypress_handler($last_tracks[0], $seq);
								usleep 100_000;
							}
							ReadMode('restore') if defined &ReadMode;
							my $removed_first_of_last_tracks;
							if($self->get_state eq 'scrobble'){
								if(@last_tracks > 0 && defined $self->{'session_key'}){
									$removed_first_of_last_tracks = shift @last_tracks;
									$self->scrobble_forked($removed_first_of_last_tracks);
								}
							}else{
								# if state was 'skip' or 'no scrobble', then don't scrobble.
								# if 'skip', then reset state to 'scrobble' for next track.
								$self->msg(2, 'skip scrobbling');
								$removed_first_of_last_tracks = shift @last_tracks;
								$self->set_state('scrobble') if $self->get_state eq 'skip';
							}
							# clean up
							if(defined $removed_first_of_last_tracks && !$self->{'keep_dl'}){
								$self->msg(1, "deleting file '" 
									. $removed_first_of_last_tracks->{'non_lastfm_file'} . "'");
								::_cleanup_file($removed_first_of_last_tracks->{'non_lastfm_file'});
							}
						}
					}
				}else{
					$self->msg(0, 'could not download track', 'warning');
				}
			}else{
				$self->msg(0, "could not connect to '$url'. " 
					. "maybe you should just try again.", 'error');
			}
		}
		return 1;
	}

	sub collect_trackinfos_bandcamp{
		my $self = shift;
		my $url = shift;
		$self->msg(1, "reading bandcamp album page '$url'");
		my ($http_status, $content) = $self->get_http_content($url);
		my $last_fm_struct = [];
		if($content =~ /\nvar TralbumData = ({\s*\n(?:\s+.*\n)+});/){
			$content = $1;
			$content =~ s/(?<=\n)[ \t]*\/\/.*\n//g;
			$content =~ s/(?<=,)[ \t]*\/\/.*//g;
			$content =~ s/^\s++([^:]+): /"$1": /mg;
			$content =~ s/" \+ "//g;
			$content = JSON::from_json($content);
			my $album_title = $content->{'current'}{'title'} or
				$self->msg(0, 'could not find album title', 'error');
			my $artist = $content->{'artist'} or
				$self->msg(0, 'could not find artist', 'error');
			my $trackinfos = $content->{'trackinfo'} or
				$self->msg(0, 'could not find trackinfos', 'error');
			if(defined $trackinfos){
				# set timestamp to (now - album_length)
				my $timestamp = $self->get_time_unix($self->{'timestamp'}) //
					$self->get_time_unix($self->{'timestamp_local'}, 'local') // time;
				# well, this is only relevant when scrobbling a full album, anyway it 
				# does not really harm other cases.
				$self->msg(2, 'set timestamp (of album end) to ' 
					. $self->get_time_iso_($timestamp));
				for my $t(@$trackinfos){
					$timestamp -= $t->{'duration'};
				}
				for my $t(@$trackinfos){
					push @$last_fm_struct, {
						'artist' => $artist,
						'track' => $t->{'title'},
						'timestamp' => int($timestamp + .5), 
						'album' => $album_title,
						'chosenByUser' => '1',
						'trackNumber' => $t->{'track_num'},
						'duration' => $t->{'duration'},
						'non_lastfm_url' => $t->{'file'}{'mp3-128'},
						'non_lastfm_about' => $content->{'current'}{'about'},
					};
					if($artist eq 'Various Artists' && $t->{'title'} =~ /^(.*) - (.*)$/){
						$last_fm_struct->[-1]{'artist'} = $1;
						$last_fm_struct->[-1]{'track'} = $2;
					}
					if(defined $last_fm_struct->[-1]{'non_lastfm_url'}){
						$last_fm_struct->[-1]{'non_lastfm_url'} =~ s/^\/\//https:\/\//;
					}
					$timestamp += $t->{'duration'};
				}
			}else{
				$self->msg(0, 'could not find trackinfos', 'error');
			}
		}else{
			$self->msg(0, 'could not find album data', 'error');
		}
		return $last_fm_struct;
	}

	sub collect_trackinfos_youtube{
		my $self = shift;
		my $url = shift;
		$self->msg(1, 'reading youtube album page');
		# tested with https://www.youtube.com/watch?v=BfZ37gpeY7A
		my ($http_status, $content) = $self->get_http_content($url);
		my $last_fm_struct = [];
		# alternative could be using 
		# https://www.googleapis.com/youtube/v3/videos?part=snippet&id=...
		#		&key=AIzaSyBSTDQ1Y6eM9Ci8hMdRo8nLbnISc6eopC4
		if($content =~ 
			/<title>(.*?) - (.*?) (?i:[(\[]?full album[)\]]? )?- YouTube<\/title>/
		){
			my $artist = $1;
			my $album_title = $2;
			if($content =~ /<p id="eow-description"[^>]*>(.*)/){
				my @description = split /<br \/>/, $1;
				my $trackinfos;
				my $counter = 1;
				for my $line(@description){
					$line =~s /<a [^>]+>|<\/a>//g;
					if($line =~ 
						/^(?i:track |)0?$counter[.: ]*"([^"]+)" \s*([0-9]{1,2}[:.][0-9]{2})/
					){
						my $duration = $self->get_time_mm_ss2s($2) // 0;
						if($counter > 1){
							$trackinfos->[-1]{'duration'} = 
								$duration - $trackinfos->[-1]{'duration'};
						}
						push @$trackinfos, {
							'track' => $1,
							'trackNumber' => $counter,
							'duration' => $duration,
						};
						++$counter;
					}else{
						$self->msg(2, 'could not find tracks yet', 'warning');
					}
				}
				# get complete video length
				$trackinfos->[-1]{'duration'} = 
					$self->youtube_get_video_length($url) - $trackinfos->[-1]{'duration'};
				$self->msg(2, Dumper($trackinfos));
				# set timestamp to (now - album_length)
				my $timestamp = $self->get_time_unix($self->{'timestamp'}) //
					$self->get_time_unix($self->{'timestamp_local'}, 'local') // time;
				$self->msg(1, 'set timestamp (of album end) to ' 
					. $self->get_time_iso_($timestamp));
				for my $t(@$trackinfos){
					$timestamp -= $t->{'duration'};
				}
				for my $t(@$trackinfos){
					push @$last_fm_struct, {
						'artist' => $artist,
						'track' => $t->{'track'},
						'timestamp' => int($timestamp + .5), 
						'album' => $album_title,
						'chosenByUser' => '1',
						'trackNumber' => $t->{'trackNumber'},
						'duration' => $t->{'duration'},
					};
					$timestamp += $t->{'duration'};
				}
			}else{
				$self->msg(0, 'could not find trackinfos', 'error');
			}
		}else{
			$self->msg(0, 'could not find artist or album title', 'error');
		}
		return $last_fm_struct;
	}

	sub delete_ugly_chars{
		my $self = shift;
		my $filename = shift;
		# delete ugly characters:
		$filename =~ s/[\x00-\x1f"\$'*\/:?\\]/_/g;
		return $filename;
	}

	sub get_all_user_data{
		my $self = shift;
		my $user = shift;
		for my $method(
			# last.fm supported methods:
			'user.getrecenttracks',
			# self-made methods:
			'user.getpastevents',
		){
			my $filename = "${user}_${method}.json";
			if(-e $filename){
				$self->msg(1, "'$filename' exists already and will not be overwritten " 
					. "but read instead.");
				$self->{'method'}{$method} = $self->load_json_file($filename);
			}else{
				if($method eq 'user.getpastevents'){
					$self->{'method'}{$method} = $self->get_user_past_events($user);
				}elsif(grep {$method eq $_} keys %{$self->{lastfm_methods}}){
					$self->{'method'}{$method} = $self->get_lastfm({
							'method' => $method,
							'user' => $user,
						}, 0
					);
				}else{
					$self->msg(0, 'unsupported method', 'error');
				}
				if(defined $self->{'method'}{$method}){
					$self->save_json_file($filename, $self->{'method'}{$method});
				}else{
					$self->msg(1, "could not fetch data for method '$method'.", 'warning');
				}
			}
		}
		return 1;
	}

	sub get_http_content{
		my $self = shift;
		my $url  = shift;
		my $http_method = shift // 'GET';
		my $more = shift;
		$self->msg(2, "getting '$url'");
		my $lwp = LWP::UserAgent->new(
			'keep_alive' => 1, 
			'timeout'    => 10, 
			'agent'      => 'dl_lfm v' . $::VERSION,
		);
		my $response = 
			$http_method eq 'HEAD' ? $lwp->head($url, %$more) :
			$http_method eq 'POST' ? $lwp->post($url, %$more) : $lwp->get($url, %$more);
		unless($response->is_success){
			$self->msg(0, $response->status_line, 'error');
		}
		if($http_method eq 'HEAD'){
			return ($response->code, $response);
		}else{
			my $content = $response->decoded_content;
			$self->msg(2, "status = " . $response->code);
			return ($response->code, $content);
		}
	}

	sub get_lastfm{
		my $self  = shift;
		my $query = shift;
		my $sign  = shift // 0;
		my $http_method = shift // 'GET';
		my %query_ext = (%$query, 'format' => 'json', 'api_key' => $self->{'api_key'});
		my $optional_params = $self->{'lastfm_methods'}{$query->{'method'}}{'optional'};
		if(grep {'limit' eq $_} @$optional_params){
			$self->msg(5, 'setting limit to 1000');
			$query_ext{'limit'} = 1000;
		}
		if(grep {'page' eq $_} @$optional_params){
			$self->msg(5, 'setting page to 1');
			$query_ext{'page'} = 1;
		}
		if(grep {'extended' eq $_} @$optional_params){
			$self->msg(5, 'setting extended to 1');
			$query_ext{'extended'} = 1;
		}
		my $finished = 0;
		my $json;
		while(!$finished){
			my $url = $self->{'lastfm_root'};
			my $sig_str = '';
			my $sep = '?';
			for my $key(sort keys %query_ext){
				unless($key =~ /^(?:callback|format|page|limit|extended)$/){
					$sig_str .= $key . $query_ext{$key};
				}
				$query_ext{$key} = uri_escape_utf8($query_ext{$key});
				$url .= $sep . $key . '=' . $query_ext{$key};
				$sep = '&' if $sep eq '?';
			}
			if($sign){
				$sig_str .= $self->{'shared_secret'};
				$self->msg(3, "signature: '$sig_str'");
				$query_ext{'api_sig'} = md5_hex(encode('utf8', $sig_str));
				$url .= $sep . 'api_sig=' . $query_ext{'api_sig'};
			}
			my ($status, $content);
			if($http_method eq 'GET'){
				($status, $content) = $self->get_http_content($url, $http_method);
			}elsif($http_method eq 'POST'){
				($status, $content) = $self->get_http_content($url, $http_method, 
					\%query_ext);
			}else{
				$self->msg(0, 'wrong http method?', 'error');
				die;
			}
			my $json_page = JSON::from_json($content);
			if(defined $json_page->{'error'}){
				$self->msg(0, Dumper($json_page), 'error');
				$json_page = {};
			}
			if(defined $query_ext{'page'}){
				my $main_key = (keys %$json_page)[0];
				$self->msg(4, "main key = '$main_key'");
				if(defined $json_page->{$main_key}{'@attr'}){
					my $total_pages = $json_page->{$main_key}{'@attr'}{'totalPages'};
					if($query_ext{'page'} >= $total_pages){
						$finished = 1;
					}else{
						$self->msg(1, "got $query_ext{'page'} of $total_pages pages");
						++$query_ext{'page'};
					}
					delete $json_page->{$main_key}{'@attr'};
				}else{
					$self->msg(3, 'could not find \'@attrs\', so probably reached end');
					$finished = 1;
				}
				if($query_ext{'page'} == 1){
					$json = $json_page;
				}else{
					my $main_subkey = (
						grep {$_ ne '@attr'} keys %{$json_page->{$main_key}}
					)[0];
					$self->msg(4, "main sub key = '$main_subkey'");
					push @{$json->{$main_key}{$main_subkey}}, 
						@{$json_page->{$main_key}{$main_subkey}};
				}
			}else{
				$json = $json_page;
				$finished = 1;
			}
		}
		return $json;
	}

	sub get_mobile_session{
		my $self = shift;
		unless(defined $self->{'session_key'}){
			unless(defined $self->{'token'}){
				if(!$self->get_token(1)){
					$self->msg(0, 'could not get a token', 'error');
					die;
				}
			}
			# credentials
			# if user name is not defined, let user type in last.fm user name
			if(not defined $self->{'username'}){
				$self->msg(1, "enter last.fm username:");
				$self->{'username'} = <STDIN>;
				chomp($self->{'username'});
			}
			$self->msg(2, "last.fm login user name is '$self->{'username'}'.");
			# if user password is not defined, search typical password places or let 
			# user type in user password
			if(not defined $self->{'password'}){
				my $pwfile = [$self->{'password_file'}];
				for(@$pwfile){
					if(-e $_){
						$self->msg(1, "using password file '$_'");
						open(my $INFILE, '<', $_) or die $!;
							chomp($self->{'password'} = <$INFILE>);
						close($INFILE);
						last;
					}
				}
				unless(defined $self->{'password'}){
					if($self->{'verbose'} >= 1){
						$self->msg(1, 'could not read password file at places: ');
						print '  ' . $pwfile->[$_] . ', ' for 0..($#$pwfile-1);
						print $pwfile->[-1] . "\n";
					}
					$self->msg(0, "enter password (will not be echoed):");
					ReadMode('raw') if defined &ReadMode;
					$self->{'password'} = ReadLine(0) if defined &ReadLine;
					chomp($self->{'password'});
					ReadMode('restore') if defined &ReadMode;
					while($self->{'password'} =~ /\x{007f}/){
						$self->{'password'} =~ s/(?:^|[^\x{007f}])\x{007f}//g;
					}
				}
			}
			if(defined $self->{'username'} and defined $self->{'password'}){
				# login
				my $json = $self->get_lastfm({
						'username' => $self->{'username'},
						'password' => $self->{'password'},
						'method'   => 'auth.getMobileSession',
						'token'    => $self->{token},
					}, 1, 'POST'
				);
				$self->{'session_key'} = $json->{'session'}{'key'};
			}else{
				$self->msg(0, 'could not login; missing username or password', 'error')
			}
			$self->{'token'} = undef unless defined $self->{'session_key'};
		}
		return $self->{'session_key'};
	}

	sub get_state{
		my $self = shift;
		return $self->{'state'};
	}

	sub get_time_iso{
		my $self = shift;
		my $unixtimestamp = shift // time();
		return strftime("%Y-%m-%dT%H:%M:%S", gmtime($unixtimestamp));
	}

	sub get_time_iso_{
		my $self = shift;
		my $unixtimestamp = shift // time();
		return strftime("%Y-%m-%d %H:%M:%S", gmtime($unixtimestamp));
	}

	sub get_time_mm_ss2s{
		my $self = shift;
		my $mm_ss = shift;
		if($mm_ss =~ /^([0-9]+):([0-9]{2}(?:\.[0-9]+)?)$/){
			return $1 * 60 + $2;
		}else{
			return undef;
		}
	}

	sub get_time_unix{
		my $self = shift;
		my $iso_timestamp = shift;
		my $local = shift;
		my $unix_timestamp;
		if(defined($iso_timestamp) && $iso_timestamp =~/^
			(?<year>[0-9]{4})-?
			(?<month>[0-9]{2})-?
			(?<mday>[0-9]{2})[T ]?
			(?<hour>[0-9]{2}):?
			(?<min>[0-9]{2}):?
			(?<sec>[0-9]{2}|)
			$/x){
			$unix_timestamp = defined($local) ? timelocal(
				$+{'sec'}, $+{'min'}, $+{'hour'}, $+{'mday'}, $+{'month'}-1, $+{'year'})
			: timegm(
				$+{'sec'}, $+{'min'}, $+{'hour'}, $+{'mday'}, $+{'month'}-1, $+{'year'});
		}
		return $unix_timestamp;
	}

	sub get_token{
		my $self   = shift;
		my $signed = shift // 0;
		my $json = $self->get_lastfm({
				'method' => 'auth.gettoken',
			}, $signed
		);
		$self->{'token'} = $json->{'token'};
		return $json->{'token'};
	}

	sub get_session{
		my $self = shift;
		$self->get_token(0) unless defined $self->{'token'};
		my $json = $self->get_lastfm({
				'method' => 'auth.getSession',
				'token' => $self->{'token'},
			}, 1
		);
		return $json->{'session'};
	}

	sub get_user_info{
		my $self = shift;
		my $user = shift;
		my $json = $self->get_lastfm({
				'method' => 'user.getinfo',
				'user' => $user,
			}, 0
		);
		return $json;
	}

	sub get_user_past_events{
		my $self = shift;
		my $user = shift;
		#my $json = $self->get_lastfm({
		#		'method' => 'user.getpastevents',
		#		'user' => $user,
		#	}, 0
		#);
		# get event overview page
		my $website = "http://www.last.fm";
		my $init_path = "/user/$user/events/";
		my $content = $self->get_http_content($website . $init_path);
		my @paths = ($content =~ /"(\Q$init_path\E[0-9]+)"/g);
		my $events;
		# get events per year
		for my $path(@paths){
			$content = $self->get_http_content($website . $path);
			# extract event tables
			$content =~ s/^.*<section id="events-section">(.+?)<\/section>.*$/$1/;
			$content =~ s/&amp;/&/g;
			# collect table heads and rows
			my @parts = $content =~ /
				<table\s+class="events-list">\s*
				<thead\s+class="sr-only">\s*
				<tr\b[^>]*>\s*((?:<th\b[^>]*>[^<]+<\/th>\s*)+)<\/tr>\s*<\/thead>\s*
				<tbody\b[^>]*>\s*
				(?:<tr\b[^>]*>\s*+(.*?)<\/tr>\s*+)+
				<\/tbody>\s*<\/table>
			/xgs;
			my @table_head;
			$self->msg(4, 'walk through table heads and rows');
			for my $part(@parts){
				if(substr($part, 1, 2) eq 'th'){
					$self->msg(4, 'found table head');
					@table_head = $part =~ /<th>\s*(.*\S)\s*<\/th>/g;
				}elsif(substr($part, 1, 2) eq 'td'){
					$self->msg(4, 'found table row');
					my @table_row = $part =~ /<td\b[^>]*>\s*(.*?)<\/td>/gs;
					if(scalar(@table_row) == scalar(@table_head)){
						$self->msg(4, 'collect event data');
						my $event; 
						for(my $i = 0; $i < @table_head; ++$i){
							if($table_row[$i] =~ /<time datetime="([^"]+)"[^>]*>/){
								$self->msg(4, 'got event timestamp');
								$event->{$table_head[$i]} = $1;
							}elsif($table_row[$i] =~ /
								<a\s+href="([^"]+)"[^>]*>\s*+
								([^<]*\S)\s*
								<\/a>.*
								<div\s+class="[^"]+\blineup">\s*([^<]*)\s*<\/div>
							/xs){
								$self->msg(4, 'got event name and lineup');
								$event->{$table_head[$i]}{'url'} = $website . $1;
								$event->{$table_head[$i]}{'name'} = $2;
								$event->{$table_head[$i]}{'lineup'} = $3;
								$event->{$table_head[$i]}{'lineup'} =~ s/\s+$//g;
								$event->{$table_head[$i]}{'lineup'} = [split /,\s*/, 
									$event->{$table_head[$i]}{'lineup'}];
							}elsif($table_row[$i] =~ /
								<div\s+class="[^"]+\bvenue--title">\s*([^<]*\S)\s*<\/div>
							/xs){
								$self->msg(4, 'got event name and venue');
								$event->{$table_head[$i]}{'title'} = $1;
								if($table_row[$i] =~ /
									<div\s+class="[^"]+\bvenue--address">\s*(.*)
								/xs){
									my $address = $1;
									while($address =~ /
										<div\s+class="[^"]+\bvenue--([^"]+)">\s*([^<]*\S)\s*<\/div>
										/gxs){
										$event->{$table_head[$i]}{$1} = $2;
									}
								}
							}elsif($table_row[$i] =~ /^\s*$/xs){
								# attendees are not interesting
							}else{
								$self->msg(0, 'could not parse events', 'error');
								$self->msg(1, $table_row[$i], 'error');
							}
						}
						push @$events, $event;
					}else{
						$self->msg(0, 'could not read page', 'error');
					}
				}else{
					$self->msg(0, 'could not read page', 'error');
				}
			}
		}
		return $events;
	}

	sub load_json_file{
		my $self = shift;
		my $file = shift;
		my $content = '';
		open(my $INFILE, '<:utf8', $file) or $self->msg(0, "$!: '$file'", 'error');
			while(!eof($INFILE)){
				$content .= getc($INFILE);
			}
		close($INFILE);
		return JSON::from_json($content);
	}

	sub msg{
		my $self           = shift;
		my $verb_threshold = shift;
		my $msg            = shift;
		my $type           = shift;
		my $caller_inc     = shift // 0;
		return 0 if $self->{'verbose'} < $verb_threshold;
		push @{$self->{'_messages'}}, {'type' => $type, 'msg' => $msg} if defined $type;
		$type = (defined $type ? "$type in ": '');
		my $timestamp = $self->get_time_iso_;
		# my ($package, $filename, $line, $subr, $has_args, $wantarray, $evaltext, 
		# $is_require, $hints, $bitmask, $hinthash) = caller(0);
		my @callers = caller(0 + $caller_inc);
		my $line = $callers[2];
		@callers = caller(1 + $caller_inc);
		my $subr = $callers[3] // '[no sub]';
		if($self->{'verbose'} > 1){
			print "$timestamp $type$subr:$line: ";
		}elsif($type ne ''){
			print "$type$subr:$line: ";
		}
		print "$msg\n";
		return 1;
	}

	sub resolve_radio_station_names{
		my $self   = shift;
		my $source = shift;
		if($source =~ /^star\s*fm\s*berlin$/i){
			$source = 'https://berlin.starfm.de/player/pls/berlin_pls_mp3.php';
		}elsif($source =~ /^star\s*fm\s*alternative$/i){
			$source = 'https://berlin.starfm.de/player/pls/alternative_pls_mp3.php';
		}elsif($source =~ /^star\s*fm\s*from\s*hell$/i){
			$source = 'https://berlin.starfm.de/player/pls/from_hell_pls_mp3.php';
		}elsif($source =~ /^star\s*fm\s*(?:rock\s*classics|classic\s*rock)$/i){
			$source = 'https://berlin.starfm.de/player/pls/classic_rock_pls_mp3.php';
		}
		return $source;
	}

	sub save_json_file{
		my $self    = shift;
		my $file    = shift;
		my $content = shift;
		open(my $OUTFILE, '>', $file) or $self->msg(0, "$!: '$file'", 'error');
			print $OUTFILE JSON::to_json($content, {'utf8' => 1, 'pretty' => 1});
		close($OUTFILE);
		$self->msg(1, "saved '$file'.");
		return 1;
	}

	sub scrobble_forked{
		my $self  = shift;
		my $track = shift;
		my $now_playing = shift;
		my $success = 0;
		if($track->{'artist'} . $track->{'track'} ne ''){
			$self->msg(2, ($now_playing ? 'updating "now playing"' : 'scrobbling') 
				. ": $track->{'artist'} -- $track->{'track'}");
			$success = 1;
			my $pid = fork();
			if(not defined $pid){
				$self->msg(0, 'resources not avilable.', 'error');
			}elsif($pid == 0){
				$self->scrobble($track, $now_playing);
				exit 0;
			}else{
				#waitpid($pid, 0);
			}
			# update stats
			if(defined($now_playing)){
				if(@{$self->{'stats'}{'played'}} == 0
					|| $self->{'stats'}{'played'}[-1]{'artist'} ne $track->{'artist'}
					|| $self->{'stats'}{'played'}[-1]{'track'} ne $track->{'track'}
				){
					push @{$self->{'stats'}{'played'}}, {
						%$track,
						'time' => time,
						'scrobbled' => 0,
					};
				}
			}else{
				if(@{$self->{'stats'}{'played'}} > 1){
					$self->{'stats'}{'played'}[-1]{'scrobbled'} = 1;
					$self->{'stats'}{'played'}[-1]{'time'} = time();
				}
			}
		}else{
			$self->msg(2, "cannot scrobble: $track->{'artist'} -- " 
				. "$track->{'track'}", 'warning');
		}
		return $success;
	}

	sub scrobble{
		my $self            = shift;
		my $track_hash_orig = shift;
		my $now_playing     = shift;
		my $die_after_scrobbling = 0;
		if(defined $track_hash_orig->{'artist'} && defined $track_hash_orig->{'track'}){
			my %track_hash = %$track_hash_orig;
			unless(defined $self->get_mobile_session()){
				$self->msg(0, 'could not get a session key', 'error');
				die;
			}
			# delete non-lastfm information
			map {delete $track_hash{$_}} grep {/^non_lastfm_/} keys %track_hash;
			# generate/convert timestamp
			if(defined $track_hash{'timestamp'}){
				# cope with iso time format
				if($track_hash{'timestamp'} =~ 
					/^[0-9]{4}(?:-[0-9]{2}){2}[ T](?:[0-9]{2}:?){2}[0-9]{2}$/){
					$track_hash{'timestamp'} = 
						$self->get_time_unix($track_hash{'timestamp'});
				}
			}else{
				$track_hash{'timestamp'} = time;
			}
			if(defined $track_hash{'duration'}){
				if($track_hash{'duration'} == 0){
					$self->msg(0, 'duration of track is 0. this will lead to errors in ' 
						. 'scrobbling. quitting after this scrobbling', 'error');
					delete $track_hash{'duration'};
					$die_after_scrobbling = 1;
				}elsif($track_hash{'duration'} <= 30){
					$self->msg(0, 'duration of track is smaller than 30 seconds and thus '
						. 'would not be scrobbled by last.fm. so I\'m deleting the information '
						. 'about the duration', 'warning');
					delete $track_hash{'duration'};
				}
			}
			if($track_hash{'track'} =~ /^[Uu]nknown$/){
				$track_hash{'track'} .= ' (sic!)';
			}
			# print info on track
			my $info_string = $now_playing ? 'updating "now playing" with' : 'scrobbling';
			$info_string .= " track " 
				. "'$track_hash{'artist'}' -- '$track_hash{'track'}'";
			if(defined $track_hash{'trackNumber'} and defined $track_hash{'album'}){
				$info_string .= " ($track_hash{'trackNumber'} " 
				. "on '$track_hash{'album'}')";
			}
			if(defined $track_hash{'duration'}){
				$info_string .= " $track_hash{'duration'}s";
			}
			if(defined $track_hash{'timestamp'}){
				$info_string .= ' at ' . $self->get_time_iso_($track_hash{'timestamp'}) 
					. ' UTC';
			}
			$self->msg(1, $info_string);
			# scrobble
			if($self->{'simulate'}){
				$self->msg(2, 'simulation only');
			}else{
				my $json = $self->get_lastfm({
						'method' => 
							($now_playing ? 'track.updatenowplaying' : 'track.scrobble'),
						'sk' => $self->{'session_key'},
						%track_hash,
					}, 1, 'POST'
				);
				# parse response for acceptance and corrections
				$self->msg(3, Dumper($json));
				my $sc = $now_playing ? $json->{'nowplaying'} : $json->{'scrobbles'};
				if(defined $sc){
					unless(defined $now_playing){
						unless(defined $sc->{'@attr'}{'accepted'} 
							&& $sc->{'@attr'}{'accepted'} == 1){
							$self->msg(0, 'scrobble data were not accepted', 'warning');
						}
						unless(defined $sc->{'@attr'}{'ignored'}
							&& $sc->{'@attr'}{'ignored'} == 0){
							$self->msg(0, 'scrobble data were ignored', 'warning');
						}
						$sc = $sc->{'scrobble'};
					}
					for my $field('album', 'artist', 'track'){
						if(defined $sc->{$field}{'corrected'}
							&& $sc->{$field}{'corrected'} == 1
						){
							$self->msg(1, "field '$field' corrected to '$sc->{$field}{'#text'}'");
						}
					}
				}else{
					$self->msg(0, ($now_playing ? 'updating "now playing"' : 'scrobbling') 
						. ' seemed to have failed.', 'warning');
				}
			}
		}else{
			$self->msg(0, 'could not ' 
				. ($now_playing ? 'update "now playing"' : 'scrobble')
				. '. artist or track name missing', 'warning');
		}
		die 'exiting because of previous error' if $die_after_scrobbling;
		return 1;
	}

	sub scrobble_from_source{
		my $self   = shift;
		my $source = shift;
		$source = $self->resolve_radio_station_names($source);
		my $scrobble_data;
		my $radio;
		if(defined $source){
			if(-e $source){ # treat files as a json source
				if($self->{'play_radio'}){
					$self->msg(0, 'don\'t know, how to play this type of source', 'error');
				}
				$scrobble_data = $self->load_json_file($source);
			}elsif($source =~ /^https?:\/\//){
				if($source =~ /^https?:\/\/bandcamp\.com\/tag\//){
					# bandcamp radio via tags
					$self->bandcamp_radio($source);
					$radio = 1;
				}elsif($source =~ /^https?:\/\/(?!www\.)[a-z0-9_-]+\.bandcamp\.com\//){
					# bandcamp album page
					if($self->{'play_radio'}){
						$self->msg(0, 'playing is not yet implemented for this type of source', 
							'error');
					}
					$scrobble_data = {
						'tracks' => $self->collect_trackinfos_bandcamp($source)
					};
				}elsif($source =~ /^https?:\/\/(?:www+\.)?youtube\.com\//){
					# youtube album page (experimental)
					if($self->{'play_radio'}){
						$self->msg(0, 'playing is not yet implemented for this type of source', 
							'error');
					}
					$scrobble_data = {
						'tracks' => $self->collect_trackinfos_youtube($source)
					};
				}else{
					# radio stream
					my $response = $self->get_http_content($source, 'HEAD');
					my $playlist = ($response->code == 200) ?
						$self->get_http_content($source) : '';
					my @sources = ($playlist =~ /File[0-9]+=\s*(https?:\/\/.*)/g);
					@sources = ($source) if @sources == 0;
					$self->msg(2, 'found following ressources: ' . Dumper(\@sources));
					my ($stream, $icy_metaint);
					for(my $i = 0; $i < @sources && !defined($stream); ++$i){
						($stream, $icy_metaint) = $self->stream_connect($sources[$i]);
						if($stream && defined($icy_metaint)){
							# endless loop (scrobbling will be done there)
							$self->stream_read_current_track($icy_metaint);
						}
					}
					$radio = 1;
				}
				unless(defined $radio || defined $scrobble_data){
					$self->msg(0, "don't know how to use the url '$source'" . 
						' or could not connect to it.', 'error');
				}
			}else{
				$self->msg(0, 'could not read source, use param --help for more info', 
					'error');
			}
		}
		if(defined($self->{'session_key'}) && defined($scrobble_data)){
			for my $track(@{$scrobble_data->{'tracks'}}){
				$self->scrobble($track);
			}
		}
		return 1;
	}

	sub scrobble_keypress_handler{
		my $self = shift;
		my $last_track = shift;
		my $seq = shift;
		my $return_value;
		if(defined $seq && @$seq > 0){
			my $key = $seq->[0];
			$self->msg(2, "key: " . length($key) . ", ". ord($key));
			$return_value = 1;
			if($key eq 'h'){
				my @str = (
					'last.fm help',
					' d - Delete current track without scrobbling and goto next track',
					' h - print this Help',
					' i - Immediately scrobble current track',
					' k - sKip scrobbling for current track',
					' n - No scrobbling any longer',
					' s - re-activate Scrobbling',
					' t - sTatistics',
				);
				map {$self->msg(1, $_)} @str;
			}elsif(ord($key) == 27){
				if(@$seq == 1){
					$self->msg(1, 'skip scrobbling of current track');
					$self->set_state('skip');
				}else{
					$self->msg(4, Dumper($seq));
					$self->msg(3, 'unrecognized short cut key');
					$return_value = 0;
				}
			}elsif($key eq '<'){
				# TODO: cope with scrobbling
			}elsif($key eq '>'){
				$self->msg(1, 'skip scrobbling of current track');
				$self->set_state('skip') unless $self->get_state eq 'no scrobble';
			}elsif($key eq 'd'){
				$self->set_state('skip') unless $self->get_state eq 'no scrobble';
				::_cleanup_file($last_track->{'non_lastfm_file'});
			}elsif($key eq 'i'){
				$self->scrobble_forked($last_track);
				$self->set_state('skip') unless $self->get_state eq 'no scrobble';
			}elsif($key eq 'k' || $key eq 'q'){
				if($self->get_state eq 'no scrobble'){
					$self->msg(1, 
						"scrobbling is deactivated anyway; to reactivate press 's'");
				}else{
					$self->msg(1, 'skip scrobbling of current track');
					$self->set_state('skip');
				}
			}elsif($key eq 'n'){
				$self->msg(1, 'no scrobbling from now on');
				$self->set_state('no scrobble');
			}elsif($key eq 's'){
				$self->msg(1, 'activate scrobbling');
				$self->set_state('scrobble');
			}elsif($key eq 't'){
				my $time_playing = time() - $self->{'stats'}{'start_time'};
				my $scrobbled =()= grep {$_->{'scrobbled'}} @{$self->{'stats'}{'played'}};
				$self->msg(1, '-'x72); 
				$self->msg(1, sprintf('playing since %s UTC (%us)', 
						'' . gmtime($self->{'stats'}{'start_time'}), 
						$time_playing,
					)
				);
				$self->msg(1, 
					sprintf('bytes received: %uMB music at rate %ukB/s', 
						$self->{'stats'}{'music_bytes'} / 1_000_000, 
						$self->{'stats'}{'music_bytes'} / (1000 * $time_playing),
					)
				);
				$self->msg(1, 
					sprintf('played tracks %u (avg. %u per hour), ' 
						. 'scrobbled %u (avg. %u per hour)', 
						scalar(@{$self->{'stats'}{'played'}}), 
						scalar(@{$self->{'stats'}{'played'}}) * 60 * 60 / $time_playing, 
						$scrobbled, 
						$scrobbled * 60 * 60 / $time_playing, 
					)
				);
				$self->msg(1, '-'x72); 
			}else{
				$return_value = 0;
			}
		}
		return $return_value;
	}

	sub set_mp3_tags{
		my $self      = shift;
		my $filename  = shift;
		my $trackinfo = shift;
		my $changed = 0;
		if(!$self->{'simulate'} && -f $filename){
			my $mp3 = MP3::Tag->new($filename);
			my $info = $mp3->autoinfo();
			unless(defined $info->{'title'} && length($info->{'title'}) > 0){
				$mp3->title_set($trackinfo->{'track'}); # sic
				++$changed;
			}
			unless(defined $info->{'album'} && length($info->{'album'}) > 0){
				$mp3->album_set($trackinfo->{'album'});
				++$changed;
			}
			unless(defined $info->{'track'} && length($info->{'track'}) > 0){
				$mp3->track_set($trackinfo->{'trackNumber'});
				++$changed;
			}
			unless(defined $info->{'artist'} && length($info->{'artist'}) > 0){
				$mp3->artist_set($trackinfo->{'artist'});
				++$changed;
			}
			# TODO: save bandcamp-url as comment
			$mp3->update_tags() if $changed > 0;
			$mp3->close();
		}
		return $changed;
	}

	sub set_state{
		my $self = shift;
		$self->{'state'} = shift;
		return 1;
	}

	sub stream_connect{
		my $self = shift;
		my $url = shift;
		my $socket;
		my $icy_metaint;
		if($url =~ /https?:\/\/([^:\/]*)(?:\:(\d+))?(?:\/(.*))?/){
			my $host = $1;
			my $port = $2 // 80;
			my $file = '/' . ($3 // '');
			$self->msg(1, "connecting to $host:$port");
			$socket = IO::Socket::INET->new(
				PeerHost => $host,
				PeerPort => $port,
				Proto => 'tcp',
			);
			if($socket){
				$self->{'socket'} = $socket;
				$self->msg(1, "requesting '$file'");
				my $send_header = 
					"GET $file HTTP/1.0\n" .
					"Icy-MetaData:1\n\n" .
					"Accept: */*\n" .
					"User-Agent: dl_lfm v$::VERSION\n\n";
				$self->msg(2, "sending header: $send_header");
				$socket->send($send_header);
				$self->msg(2, "waiting for reply");
				my $header = <$socket>;
				chomp($header);
				unless($header =~ /200|OK/){
					$self->msg(1, "header = $header");
					$self->msg(0, 'reading of stream header failed.', 'warning');
					return (undef, undef);
				}
				$self->msg(2, $header);
				my %icy_info = ();
				while($header = <$socket>){
					$header =~ s/[\r\n]+$//;
					$icy_info{'content-type'} = $1 if $header =~ /^Content-Type:(.+)/;
					$icy_info{'bitrate'} = $1      if $header =~ /^icy-br:([0-9]+)/;
					$icy_info{'genre'} = $1        if $header =~ /^icy-genre:(.+)/;
					$icy_info{'radio'} = $1        if $header =~ /^icy-name:(.+)/;
					$icy_info{'url'} = $1          if $header =~ /^icy-url:(.+)/;
					if($header =~ /^icy-metaint:([0-9]+)/){
						$icy_metaint = $1;
					}
					$self->msg(3, "header: $header");
					last unless $header =~ /\S/;
				}
				if(keys(%icy_info) > 0){ # print some information
					$self->msg(1, 'radio: ' . ($icy_info{'radio'} // 'unknown') . ' from ' 
						. ($icy_info{'url'} // 'unknown'));
					$self->msg(1, 'audio type: ' . ($icy_info{'content-type'} // 'unknown') 
						. ' with bitrate ' . ($icy_info{'bitrate'} // 'unknown'));
					$self->msg(1, 'genre: ' . ($icy_info{'genre'} // 'unknown'));
				}
				defined $icy_metaint or $self->msg(0, 'no icy meta intervall found', 
					'warning');
			}else{
				$self->msg(1, "socket creation failed: $!", 'notice');
			}
		}else{
			$self->msg(2, "could not read url", 'notice');
		}
		return ($socket, $icy_metaint);
	}

	sub stream_parse_icy_info{
		my $self = shift;
		my $str  = shift;
		if($str =~ /^StreamTitle='(?:NEXT: ?)?(.*) - (.*)';(?:StreamUrl='|$)/){
			return {
				'artist' => $1,
				'track'  => $2,
			}
		}else{
			return $str;
		}
	}

	sub stream_read_current_track{
		my $self        = shift;
		my $icy_metaint = shift;
		# out file or stream, e.g. '>test.mp3' or '| vlc -'
		my $outstream   = $self->{'stream_out'} // '| vlc -'; 
		my $content; 
		my $byte_count = 0; 
		my $byte_inc_default = 1024; 
		my $byte_inc = (defined($icy_metaint) && $byte_inc_default >= $icy_metaint)
			? $icy_metaint : $byte_inc_default; 
		my $info = '';
		my $HANDLER;
		if($self->{'play_radio'}){
			open($HANDLER, $outstream) 
				or die "error: cannot pipe input to '" . substr($outstream, 1) . "': $!\n";
			$self->msg(1, "redirecting HTTP filestream to '$outstream'");
		}
		my %last_track = ('artist' => '', 'track' => '');
		my $socket = $self->{'socket'};
		unless(defined $socket){
			$self->msg(0, 'socket not defined. did you call stream_connect already?', 
				'error');
			return 0;
		}
		$SIG{'CHLD'} = 'IGNORE'; # avoid creating zombies with fork
		$self->set_state('scrobble');
		ReadMode('cbreak') if defined &ReadMode;
		while($socket->read($content, $byte_inc)){
			$self->{'stats'}{'music_bytes'} += $byte_inc;
			#printf "read %d, %d\n", length($content), $byte_inc;
			my $seq = $self->{'mplayer'}->read_key;
			$self->scrobble_keypress_handler(\%last_track, $seq);
			print $HANDLER $content if $self->{'play_radio'};
			if(defined $icy_metaint){
				$byte_count += $byte_inc;
				if($byte_count == $icy_metaint){
					$socket->read($content, 1);
					my $length = 16 * ord($content);
					if($length > 0){
						$socket->read($content, $length);
						$content =~ s/\s+$//;
						$self->msg(4, $content);
						if($content ne $info){ # if new content
							$info = $content;
							if($info =~ /\S/){
								my $current_track = $self->stream_parse_icy_info($info);
								if(ref $current_track eq 'HASH'){
									$current_track->{'chosenByUser'} = '0';
									# if track is other than before
									if($last_track{'artist'} ne $current_track->{'artist'} ||
										$last_track{'track'} ne $current_track->{'track'}){
										# scrobble if state is not 'skip'.
										if($self->get_state eq 'scrobble'){
											if(defined $self->{'session_key'}){
												$self->scrobble_forked(\%last_track);
											}
										}else{
											# if state was 'skip', then don't scrobble, but reset state 
											#  to 'scrobble' for next track.
											$self->msg(2, 'skip scrobbling');
											$self->set_state('scrobble') if $self->get_state eq 'skip';
										}
										# update last_track
										$last_track{'artist'} = $current_track->{'artist'};
										$last_track{'track'}  = $current_track->{'track'};
									}
									if(defined $self->{'session_key'}){
										$self->scrobble_forked($current_track, 'now playing');
									}
								}else{
									# if current track can't be extracted, then print complete info
									$self->msg(1, $current_track);
								}
							}
						}
					}
					$byte_count = 0;
					$byte_inc = $byte_inc_default < $icy_metaint ? $byte_inc_default
						: $icy_metaint;
				}elsif($byte_count + $byte_inc > $icy_metaint){
					$byte_inc = $icy_metaint - $byte_count;
				}
			}
		}
		ReadMode('restore') if defined &ReadMode;
		close $HANDLER if $self->{'play_radio'};
		$socket->close;
		return 1;
	}

	sub youtube_get_video_length{
		my $self = shift;
		my $url  = shift;
		my $api_key = 'AIzaSyBSTDQ1Y6eM9Ci8hMdRo8nLbnISc6eopC4';
		my $length;
		# extract youtube video id
		if($url =~ /youtube\.com\/(?:watch\?v=|v\/)([a-zA-Z0-9]+)/){
			my $id = $1;
			my $content = $self->get_http_content(
				'https://www.googleapis.com/youtube/v3/videos?part=contentDetails&id=' 
				. $id . '&key=' . $api_key);
			$content = JSON::from_json($content);
			if(defined $content->{'items'}[0]{'contentDetails'}{'duration'}){
				$length = $content->{'items'}[0]{'contentDetails'}{'duration'};
				if($length =~ 
					/^P(?:([0-9]+D|))T(?:([0-9]+)H|)(?:([0-9]+)M|)(?:([0-9]+)S|)$/
				){
					$length = ((($1 // 0) * 24 + ($2 // 0)) * 60 + ($3 // 0)) * 60 
						+ ($4 // 0);
				}else{
					$self->msg(0, 'could not extract youtube video length', 'error');
				}
			}else{
				$self->msg(0, 'could not get youtube video information', 'error');
			}
		}else{
			$self->msg(0, 'could not extract youtube video id', 'error');
		}
		return $length;
	}

}

# main
my $params = syntaxCheck(@ARGV);
my $lfm_dl = Lastfm_dl->new({
		'keep'            => $params->{'keep'},
		'password'        => $params->{'password'},
		'password-file'   => $params->{'password-file'},
		'play-radio'      => defined($params->{'radio'}),
		'stream-out'      => $params->{'stream-out'},
		'test'            => $params->{'test'},
		'timestamp'       => $params->{'timestamp'},
		'timestamp-local' => $params->{'timestamp-local'},
		'username'        => $params->{'user'},
		'verbose'         => $params->{'verbose'},
	}
);
#$lfm_dl->authenticate;
#$lfm_dl->get_session;
if($params->{'dl'}){
	if(defined $params->{'user'}){
		$lfm_dl->get_all_user_data($params->{'user'});
	}else{
		$lfm_dl->msg(0, 'username required', 'error');
	}
}
if(defined($params->{'radio'}) || defined($params->{'scrobble'})){
	my $url = $params->{'radio'} // $params->{'scrobble'};
	if(defined($params->{'user'}) || defined($params->{'scrobble'})){
		# login to last.fm
		$lfm_dl->get_mobile_session() 
			or die "could not login at last.fm with given credentials\n";
	}
	$lfm_dl->scrobble_from_source($url);
}

__END__

=head1 NAME

downloads last.fm profiles and helps scrobbling from files or radio stations

=head1 DESCRIPTION

dl_lfm has several functions, it

* downloads a last.fm profile

* helps scrobbling from json files, radio streaming stations (using vlc) or some 
webpages (supported: bandcamp.com and experimentally youtube.com)

* plays and scrobbles randomly picked tracks from bandcamp.com like a radio 
(needs mplayer installed)

=head1 SYNOPSIS

dl_lfm [options]

      --dl                    download all data from user (requires -u)
      --keep                  when using bandcamp radio, keep downloaded files 
                               (default: delete after playing)
      --password=string       password
      --password-file=string  a file containing your last-fm password
  -r  --radio=src             use radio station to play some tracks; if --user is 
                               set, then tracks will be scrobbled, see --man for 
                               suported urls; needs mplayer for bandcamp.
  -s  --scrobble=src          use this file or radio station to scrobble some tracks
                               without playing them, see --man for suported file 
                               types and urls
      --stream-out=dest       use this destination to send the stream to 
                               (if scrobbling from stream), default = '| vlc -'
  -t, --test                  don't scrobble anything, simulate only
      --timestamp=string      set timestamp (UTC) of album end, when scrobbling from 
                               bandcamp.com or yaml file; treat string as UTC timestamp string
      --timestamp-local=str   same as --timestamp, but treat str as local timestamp
                               (not UTC)
  -u, --user=string           username

meta:

  -V, --version               display version and exit.
  -h, --help                  display brief help
      --man                   display long help (man page)
  -q, --silent                same as --verbose=0
  -v, --verbose               same as --verbose=1 (default)
  -vv,--very-verbose          same as --verbose=2
  -v, --verbose=x             grade of verbosity
                               x=0: no output
                               x=1: default output
                               x=2: much output

example:

  dl_lfm --dl --user='testtesttest123123123'

    gets all public information on user 'testtesttest123123123' from last.fm 
    and saves that data into several files.

  dl_lfm --scrobble='https://someincredibleband.bandcamp/album/someawsomealbum' 
  --user="testtest123123"

    scrobbles given album to last.fm profile of user 'testtest12123'. the 
    scrobbling timestamps will be set as if you had just now finished listening to
    the album. tracks will not be played.

  dl_lfm --scrobble='https://someincredibleband.bandcamp/album/someawsomealbum' 
  --user="testtest123123" --timestamp='2016-01-01 12:34'

    same as above but sets the scrobbling timestamp as if you had finished 
    listening to the album at 2016-01-01 12:34 UTC.

  dl_lfm --radio='https://bandcamp.com/tag/progressivepostfuneraldoommetal' 

    plays random tracks of given tags from bandcamp.com. uses mplayer for playing.

  dl_lfm --radio='https://bandcamp.com/tag/progressivepostfuneraldoommetal' 
  --user="cutelittlesquirrel"

    plays random tracks of given tags from bandcamp.com and scrobbles them to 
    last.fm profile of user cutelittlesquirrel.

=head1 OPTIONS

=over 8

=item B<--dl>

requires B<--user>=I<username>.

gets all public information on I<username> from last.fm and saves that data into 
several files.
be aware that those can get quite big. a scrobble is approximately 2KiB large. 
so 10k scrobbles cost around 20MiB free space on your hard drive.

=item B<--password>=I<string>

use this password for last.fm user B<--user>=I<username>.

=item B<--password-file>=I<string>

use the first line of this file a password for last.fm. 
default = $HOME/.password_lastfm

=item B<--radio>=I<source>, B<-r> I<source>

use I<source> for playing some tracks. if B<--user>=I<username> is set, then the 
played tracks will be scrobbled to last.fm.

supported urls or radio streaming stations: 

* https://{band or label name}.bandcamp.com/album/{albumname}

* https://bandcamp.com/tag/{tagname}

* {protocol}://{ip address}:{port}

=item B<--scrobble>=I<source>, B<-s> I<source>

same as B<--radio>, but without playing the tracks (if possible).

requires B<--user>=I<username> for last.fm.

use I<source> for scrobbling some tracks to last.fm.

supported file type(s): json

OR

supported urls or radio streaming stations: 

* https://{band or label name}.bandcamp.com/album/{albumname}

* https://bandcamp.com/tag/{tagname}

* {protocol}://{ip address}:{port}

=item B<--stream-out>=I<destination>

if playing a radio stream (see B<--radio>), then this param can be used to adjust
the destination where the stream data shall forwarded to.

default: I<destination> = '| vlc -', i.e., the stream data will be piped '|' to a 
new instance of vlc, where the parameter '-' means, that vlc will read the stream 
from STDIN.

other possibilities: '> output.mp3' to pipe the streaming data directly into a file.

=item B<--user>=I<username>, B<-u> I<username>

use this last.fm username, e.g. for B<--dl>

=item B<--test>, B<-t>

don't scrobble anything, but simulate only

=item B<--version>, B<-V>

prints version and exits.

=item B<--help>, B<-h>, B<-?>

prints a brief help message and exits.

=item B<--man>

prints the manual page and exits.

=item B<--verbose>=I<number>, B<-v> I<number>

set grade of verbosity to I<number>. if I<number>==0 then no output
will be given, except hard errors. the higher I<number> is, the more 
output will be printed. default: I<number> = 1.

=item B<--silent, --quiet, -q>

same as B<--verbose=0>.

=item B<--very-verbose, -vv>

same as B<--verbose=3>. you may use B<-vvv> for B<--verbose=4> a.s.o.

=item B<--verbose, -v>

same as B<--verbose=2>.

=back

=head1 LICENCE

Copyright (c) 2017, seth
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

originally written by seth

=cut
